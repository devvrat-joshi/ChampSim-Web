#include "ooo_cpu.h"

#define BIMODAL_TABLE_SIZE 16384
#define BIMODAL_PRIME 16381
#define MAX_COUNTER 3
#define PERCEPTRON_HISTORY	24
#define NUM_PERCEPTRONS		163
#define PERCEPTRON_BITS		8
#define MAX_WEIGHT		((1<<(PERCEPTRON_BITS-1))-1)
#define MIN_WEIGHT		(-(MAX_WEIGHT+1))
#define THETA			((int) (1.93 * PERCEPTRON_HISTORY + 14))
#define NUM_UPDATE_ENTRIES	100
#define hybrid_history 600000
int per;
int HYBRID[hybrid_history];
uint8_t bimod;
typedef struct {
	int	weights[PERCEPTRON_HISTORY+1];
} perceptron;
typedef struct {
	char dummy_counter;

	int prediction, output;

	unsigned long long int history;

	perceptron *perc;
} perceptron_state;
perceptron perceptrons[NUM_CPUS][NUM_PERCEPTRONS];
perceptron_state perceptron_state_buf[NUM_CPUS][NUM_UPDATE_ENTRIES];
int perceptron_state_buf_ctr[NUM_CPUS];
unsigned long long int spec_global_history[NUM_CPUS], global_history[NUM_CPUS];
perceptron_state *u[NUM_CPUS];
int bimodal_table[NUM_CPUS][BIMODAL_TABLE_SIZE];

void initialize_perceptron (perceptron *p) {
    int	i;

    for (i=0; i<=PERCEPTRON_HISTORY; i++) p->weights[i] = 0;
}

void O3_CPU::initialize_branch_predictor()
{
    for(int i = 0; i < BIMODAL_TABLE_SIZE; i++)
        bimodal_table[0][i] = 0;
    spec_global_history[0] = 0;
    global_history[0] = 0;
    perceptron_state_buf_ctr[0] = 0;
    for (int i=0; i<NUM_PERCEPTRONS; i++)
        initialize_perceptron (&perceptrons[0][i]);
}

uint8_t predict_branch_p(uint64_t ip)
{
    uint64_t address = ip;

    int	
        index,
        i,
        output,
        *w;
    unsigned long long int 
        mask;
    perceptron 
        *p;

    u[0] = &perceptron_state_buf[0][perceptron_state_buf_ctr[0]++];
    if (perceptron_state_buf_ctr[0] >= NUM_UPDATE_ENTRIES)
        perceptron_state_buf_ctr[0] = 0;

    index = address % NUM_PERCEPTRONS;

    p = &perceptrons[0][index];
    w = &p->weights[0];

    output = *w++;

    for (mask=1,i=0; i<PERCEPTRON_HISTORY; i++,mask<<=1,w++) {
        if (spec_global_history[0] & mask)
            output += *w;
        else
            output += -*w;
    }

    u[0]->output = output;
    u[0]->perc = p;
    u[0]->history = spec_global_history[0];
    u[0]->prediction = output >= 0;
    u[0]->dummy_counter = u[0]->prediction ? 3 : 0;

    spec_global_history[0] <<= 1;
    spec_global_history[0] |= u[0]->prediction;
    return u[0]->prediction;
}

void last_branch_result_p(uint64_t ip, uint8_t taken)
{
    int	
        i,
        y, 
        *w;

    unsigned long long int
        mask, 
        history;

    global_history[0] <<= 1;
    global_history[0] |= taken;

    if (u[0]->prediction != taken) spec_global_history[0] = global_history[0];

    if (u[0]->output > THETA)
        y = 1;
    else if (u[0]->output < -THETA)
        y = 0;
    else
        y = 2;
    if (y == 1 && taken) return;
    if (y == 0 && !taken) return;

    w = &u[0]->perc->weights[0];

    if (taken)
        (*w)++;
    else
        (*w)--;
    if (*w > MAX_WEIGHT) *w = MAX_WEIGHT;
    if (*w < MIN_WEIGHT) *w = MIN_WEIGHT;

    w++;

    history = u[0]->history;

    for (mask=1,i=0; i<PERCEPTRON_HISTORY; i++,mask<<=1,w++) {
        if (!!(history & mask) == taken) { // a common trick to conver to boolean => !!x is 1 iff x is not zero, in this case history is positively correlated with branch outcome
            (*w)++;
            if (*w > MAX_WEIGHT) *w = MAX_WEIGHT;
        } else {
            (*w)--;
            if (*w < MIN_WEIGHT) *w = MIN_WEIGHT;
        }
    }
}

uint8_t O3_CPU::predict_branch(uint64_t ip)
{
    uint32_t hash = ip % BIMODAL_PRIME;
    uint8_t prediction = (bimodal_table[0][hash] >= ((MAX_COUNTER + 1)/2)) ? 1 : 0;
    bimod=prediction;
    per = predict_branch_p(ip);
    long long int mask=1;
    for(int i=0;i<18;i++)mask = (mask<<1)|1;
    int hash_value = (mask)&(ip^spec_global_history[cpu]);
    if(HYBRID[hash_value]<2)
        return u[cpu]->prediction;
    else
        return per;
}

void O3_CPU::last_branch_result(uint64_t ip, uint8_t taken, uint64_t target)
{
    uint32_t hash = ip % BIMODAL_PRIME;

    if (taken && (bimodal_table[0][hash] < MAX_COUNTER))
        bimodal_table[0][hash]++;
    else if ((taken == 0) && (bimodal_table[0][hash] > 0))
        bimodal_table[0][hash]--;

    last_branch_result_p(ip,taken);
    long long int mask=1;
    for(int i=0;i<18;i++)mask = (mask<<1)|1;
    int hash_value = (mask)&(ip^spec_global_history[0]);
    if(bimod!=taken && u[0]->prediction==taken){
        if(HYBRID[hash_value]>0)HYBRID[hash_value] -= 1;
    }
    if(bimod==taken && u[0]->prediction!=taken){
        if(HYBRID[hash_value]<3)HYBRID[hash_value] += 1;
    }
}

