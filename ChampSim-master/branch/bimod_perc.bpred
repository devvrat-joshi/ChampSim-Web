#include "ooo_cpu.h"

#define BIMODAL_TABLE_SIZE 16384
#define BIMODAL_PRIME 16381
#define MAX_COUNTER 3
#define PERCEPTRON_HISTORY	24
#define NUM_PERCEPTRONS		163
#define PERCEPTRON_BITS		8
#define MAX_WEIGHT		((1&lt;&lt;(PERCEPTRON_BITS-1))-1)
#define MIN_WEIGHT		(-(MAX_WEIGHT+1))
#define THETA			((int) (1.93 * PERCEPTRON_HISTORY + 14))
#define NUM_UPDATE_ENTRIES	100
#define hybrid_history 600000
int per;
int HYBRID[hybrid_history];
uint8_t bimod;
typedef struct {
	int	weights[PERCEPTRON_HISTORY+1];
} perceptron;
typedef struct {
	char dummy_counter;

	int prediction, output;

	unsigned long long int history;

	perceptron *perc;
} perceptron_state;
perceptron perceptrons[NUM_CPUS][NUM_PERCEPTRONS];
perceptron_state perceptron_state_buf[NUM_CPUS][NUM_UPDATE_ENTRIES];
int perceptron_state_buf_ctr[NUM_CPUS];
unsigned long long int spec_global_history[NUM_CPUS], global_history[NUM_CPUS];
perceptron_state *u[NUM_CPUS];
int bimodal_table[NUM_CPUS][BIMODAL_TABLE_SIZE];

void initialize_perceptron (perceptron *p) {
    int	i;

    for (i=0; i&lt;=PERCEPTRON_HISTORY; i++) p-&gt;weights[i] = 0;
}

void O3_CPU::initialize_branch_predictor()
{
    for(int i = 0; i &lt; BIMODAL_TABLE_SIZE; i++)
        bimodal_table[0][i] = 0;
    spec_global_history[0] = 0;
    global_history[0] = 0;
    perceptron_state_buf_ctr[0] = 0;
    for (int i=0; i&lt;NUM_PERCEPTRONS; i++)
        initialize_perceptron (&amp;perceptrons[0][i]);
}

uint8_t predict_branch_p(uint64_t ip)
{
    uint64_t address = ip;

    int	
        index,
        i,
        output,
        *w;
    unsigned long long int 
        mask;
    perceptron 
        *p;

    u[0] = &amp;perceptron_state_buf[0][perceptron_state_buf_ctr[0]++];
    if (perceptron_state_buf_ctr[0] &gt;= NUM_UPDATE_ENTRIES)
        perceptron_state_buf_ctr[0] = 0;

    index = address % NUM_PERCEPTRONS;

    p = &amp;perceptrons[0][index];
    w = &amp;p-&gt;weights[0];

    output = *w++;

    for (mask=1,i=0; i&lt;PERCEPTRON_HISTORY; i++,mask&lt;&lt;=1,w++) {
        if (spec_global_history[0] &amp; mask)
            output += *w;
        else
            output += -*w;
    }

    u[0]-&gt;output = output;
    u[0]-&gt;perc = p;
    u[0]-&gt;history = spec_global_history[0];
    u[0]-&gt;prediction = output &gt;= 0;
    u[0]-&gt;dummy_counter = u[0]-&gt;prediction ? 3 : 0;

    spec_global_history[0] &lt;&lt;= 1;
    spec_global_history[0] |= u[0]-&gt;prediction;
    return u[0]-&gt;prediction;
}

void last_branch_result_p(uint64_t ip, uint8_t taken)
{
    int	
        i,
        y, 
        *w;

    unsigned long long int
        mask, 
        history;

    global_history[0] &lt;&lt;= 1;
    global_history[0] |= taken;

    if (u[0]-&gt;prediction != taken) spec_global_history[0] = global_history[0];

    if (u[0]-&gt;output &gt; THETA)
        y = 1;
    else if (u[0]-&gt;output &lt; -THETA)
        y = 0;
    else
        y = 2;
    if (y == 1 &amp;&amp; taken) return;
    if (y == 0 &amp;&amp; !taken) return;

    w = &amp;u[0]-&gt;perc-&gt;weights[0];

    if (taken)
        (*w)++;
    else
        (*w)--;
    if (*w &gt; MAX_WEIGHT) *w = MAX_WEIGHT;
    if (*w &lt; MIN_WEIGHT) *w = MIN_WEIGHT;

    w++;

    history = u[0]-&gt;history;

    for (mask=1,i=0; i&lt;PERCEPTRON_HISTORY; i++,mask&lt;&lt;=1,w++) {
        if (!!(history &amp; mask) == taken) { // a common trick to conver to boolean =&gt; !!x is 1 iff x is not zero, in this case history is positively correlated with branch outcome
            (*w)++;
            if (*w &gt; MAX_WEIGHT) *w = MAX_WEIGHT;
        } else {
            (*w)--;
            if (*w &lt; MIN_WEIGHT) *w = MIN_WEIGHT;
        }
    }
}

uint8_t O3_CPU::predict_branch(uint64_t ip)
{
    uint32_t hash = ip % BIMODAL_PRIME;
    uint8_t prediction = (bimodal_table[0][hash] &gt;= ((MAX_COUNTER + 1)/2)) ? 1 : 0;
    bimod=prediction;
    per = predict_branch_p(ip);
    long long int mask=1;
    for(int i=0;i&lt;18;i++)mask = (mask&lt;&lt;1)|1;
    int hash_value = (mask)&amp;(ip^spec_global_history[cpu]);
    if(HYBRID[hash_value]&lt;2)
        return u[cpu]-&gt;prediction;
    else
        return per;
}

void O3_CPU::last_branch_result(uint64_t ip, uint8_t taken, uint64_t target)
{
    uint32_t hash = ip % BIMODAL_PRIME;

    if (taken &amp;&amp; (bimodal_table[0][hash] &lt; MAX_COUNTER))
        bimodal_table[0][hash]++;
    else if ((taken == 0) &amp;&amp; (bimodal_table[0][hash] &gt; 0))
        bimodal_table[0][hash]--;

    last_branch_result_p(ip,taken);
    long long int mask=1;
    for(int i=0;i&lt;18;i++)mask = (mask&lt;&lt;1)|1;
    int hash_value = (mask)&amp;(ip^spec_global_history[0]);
    if(bimod!=taken &amp;&amp; u[0]-&gt;prediction==taken){
        if(HYBRID[hash_value]&gt;0)HYBRID[hash_value] -= 1;
    }
    if(bimod==taken &amp;&amp; u[0]-&gt;prediction!=taken){
        if(HYBRID[hash_value]&lt;3)HYBRID[hash_value] += 1;
    }
}


